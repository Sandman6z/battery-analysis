name: Battery Analysis CI-CD

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    runs-on: windows-latest
    permissions:
      contents: write
    env:
      PYTHONIOENCODING: utf-8
      PYTHONUTF8: 1
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python 3.13
      uses: actions/setup-python@v5
      with:
        python-version: '3.13'
    
    - name: Install uv
      uses: astral-sh/setup-uv@v3
    
    - name: Create and activate virtual environment
      run: |
        # 创建虚拟环境
        python -m venv .venv
        # 激活虚拟环境（PowerShell命令）
        .\.venv\Scripts\Activate.ps1
        # 验证虚拟环境激活状态
        Write-Host "虚拟环境已激活: $(Get-Command python).Source"
    
    - name: Install dependencies using uv
      run: |
        # 确保激活虚拟环境
        .\.venv\Scripts\Activate.ps1
        uv pip install -e '.[dev,build]'
    
    - name: Lint with flake8
      run: |
        uv add flake8
        # 停止构建如果有Python语法错误或未定义名称
        uv run flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude=.venv,__pycache__,build,dist
        # 警告但不停止构建其他问题
        uv run flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics --exclude=.venv,__pycache__,build,dist
    
    - name: Run tests with pytest
      run: |
        # 确保激活虚拟环境
        .\.venv\Scripts\Activate.ps1
        uv run pytest
    
    - name: 设置Python DLL环境变量
      run: |
        # 获取Python安装路径
        $pythonPath = (Get-Command python).Source
        $pythonDir = Split-Path -Parent $pythonPath
        $pythonHome = Split-Path -Parent $pythonDir
        
        # 检查Python DLL位置并设置环境变量
        Write-Host "Python可执行文件路径: $pythonPath"
        Write-Host "Python目录: $pythonDir"
        Write-Host "Python主目录: $pythonHome"
        
        # 检查常见的DLL路径 - PowerShell数组使用空格分隔元素
        $possibleDllPaths = @(
            (Join-Path $pythonDir 'python313.dll'),
            (Join-Path $pythonHome 'python313.dll'),
            (Join-Path (Join-Path $pythonHome 'DLLs') 'python313.dll'),
            (Join-Path $pythonHome 'libs/python313.dll')
        )
        
        $dllFound = $false
        foreach ($path in $possibleDllPaths) {
            Write-Host "检查DLL路径: $path"
            if (Test-Path $path) {
                Write-Host "找到Python DLL: $path"
                # 设置环境变量，build脚本会使用它
                echo "PYTHON_DLL_PATH=$path" >> $env:GITHUB_ENV
                $dllFound = $true
                break
            }
        }
        
        # 添加错误处理，确保DLL被找到
        if (-not $dllFound) {
            Write-Error "错误：未找到python313.dll文件。尝试的路径："
            foreach ($path in $possibleDllPaths) {
                Write-Error "  - $path"
            }
            exit 1
        }
    
    - name: Run build script
      run: |
        uv run python scripts/build.py Release
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: battery-analysis-build
        path: build/
        retention-days: 7

  release:
    runs-on: windows-latest
    permissions:
      contents: write
    needs: build-and-test  # Release job depends on build-and-test to ensure build artifacts are available and can't run in parallel
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/'))
    steps:
    - uses: actions/checkout@v4
      
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: battery-analysis-build
        path: build/

    - name: Generate release information
      id: release_info
      run: |
        if ("${{ github.ref }}" -eq 'refs/heads/main') {
          # main branch push: use version from toml + beta + 6-digit SHA
          $pyprojectContent = Get-Content -Path pyproject.toml -Raw
          if ($pyprojectContent -match 'version\s*=\s*"([^"]+)"') {
            $version = $matches[1]
            $shortSha = "${{ github.sha }}".Substring(0, 6)
            $releaseName = "v${version}-beta.${shortSha}"
            echo "release_name=$releaseName" >> $env:GITHUB_OUTPUT
            echo "is_prerelease=True" >> $env:GITHUB_OUTPUT
            echo "is_latest=False" >> $env:GITHUB_OUTPUT
            echo "release_type=prerelease" >> $env:GITHUB_OUTPUT
            Write-Host "Generated prerelease name: $releaseName"
          } else {
            Write-Error "Failed to extract version from pyproject.toml"
            exit 1
          }
        } else {
          # tag push: use tag name, push as official release
          $tagName = "${{ github.ref }}".Replace('refs/tags/', '')
          echo "release_name=$tagName" >> $env:GITHUB_OUTPUT
          echo "is_prerelease=False" >> $env:GITHUB_OUTPUT
          echo "is_latest=True" >> $env:GITHUB_OUTPUT
          echo "release_type=release" >> $env:GITHUB_OUTPUT
          Write-Host "Generated release name: $tagName"
        }
      shell: powershell

    - name: Create GitHub Release and Upload Assets
      uses: actions/github-script@v7
      with:
        script: |
          const releaseName = '${{ steps.release_info.outputs.release_name }}';
          const isPrerelease = ${{ steps.release_info.outputs.is_prerelease == 'True' }};
          const isLatest = ${{ steps.release_info.outputs.is_latest == 'True' }};
          const tagName = ${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || steps.release_info.outputs.release_name }};
          const releaseType = isPrerelease ? '预发布构建版本' : '正式构建版本';
          
          // 创建release
          const release = await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: tagName,
            name: releaseName,
            body: `${releaseType} - Release模式\n构建编号: ${{ github.run_number }}\n版本号: ${releaseName}\n提交SHA: ${{ github.sha }}\n分支: ${{ github.ref_name }}`,
            draft: false,
            prerelease: isPrerelease,
            make_latest: isLatest,
            target_commitish: '${{ github.sha }}'
          });
          
          console.log('Release created:', release.data.html_url);
          
          // 获取构建产物
          const fs = require('fs');
          const path = require('path');
          
          const exeFiles = await fs.promises.readdir('build/Release')
            .then(files => files.filter(file => file.endsWith('.exe')).map(file => path.join('build/Release', file)));
          
          const iniFiles = await fs.promises.readdir('build/Release')
            .then(files => files.filter(file => file.endsWith('.ini')).map(file => path.join('build/Release', file)));
          
          const allFiles = [...exeFiles, ...iniFiles];
          console.log('Files to upload:', allFiles);
          
          // 上传文件
          for (const file of allFiles) {
            console.log(`Uploading ${file}...`);
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.data.id,
              name: path.basename(file),
              data: await fs.promises.readFile(file)
            });
            console.log(`Uploaded ${file}`);
          }
          
          console.log('All assets uploaded successfully');
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}